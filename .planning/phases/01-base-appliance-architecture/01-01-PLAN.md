---
phase: 01-base-appliance-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spec/01-superlink-appliance.md
autonomous: true

must_haves:
  truths:
    - "A reader can identify every component in the SuperLink appliance (base OS, Docker engine, contextualization agent, Flower container)"
    - "A reader can trace the SuperLink boot sequence from OS boot through Flower container startup to OneGate readiness publication"
    - "The SuperLink spec includes Docker run configuration, port mappings, volume mounts, and systemd integration"
    - "The SuperLink spec defines the OneGate publication contract (what data is published, when, and in what format)"
    - "The spec defines the pre-baked image strategy with version override and fallback mechanism"
  artifacts:
    - path: "spec/01-superlink-appliance.md"
      provides: "Complete SuperLink appliance specification"
      contains: "## SuperLink Appliance"
  key_links:
    - from: "spec/01-superlink-appliance.md"
      to: "Flower CLI reference"
      via: "CLI flag mapping in Docker run config"
      pattern: "--insecure.*--isolation subprocess"
    - from: "spec/01-superlink-appliance.md"
      to: "OpenNebula OneGate"
      via: "FL_READY publication after health check"
      pattern: "FL_READY=YES"
---

<objective>
Write the SuperLink (Flower server) appliance specification section.

Purpose: This is the foundational spec section that defines how the FL coordinator runs as a marketplace appliance. It covers the QCOW2 image contents, Docker-in-VM architecture, linear boot sequence, health checking, OneGate readiness publication, and failure handling. An engineer reading this section should be able to build the SuperLink appliance image and contextualization scripts without further questions.

Output: `spec/01-superlink-appliance.md` -- a complete spec section covering APPL-01 (SuperLink appliance with QCOW2 packaging, Docker-in-VM architecture, boot-time initialization, and configuration parameters).
</objective>

<execution_context>
@/home/pablo/.claude/get-shit-done/workflows/execute-plan.md
@/home/pablo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/pablo/flower-opennebula/.planning/PROJECT.md
@/home/pablo/flower-opennebula/.planning/ROADMAP.md
@/home/pablo/flower-opennebula/.planning/STATE.md
@/home/pablo/flower-opennebula/.planning/phases/01-base-appliance-architecture/01-CONTEXT.md
@/home/pablo/flower-opennebula/.planning/phases/01-base-appliance-architecture/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create spec directory and write SuperLink appliance spec section</name>
  <files>spec/01-superlink-appliance.md</files>
  <action>
Create the `spec/` directory at the project root (`/home/pablo/flower-opennebula/spec/`).

Write `spec/01-superlink-appliance.md` as a complete technical specification section. This is a SPEC DOCUMENT, not code. Write it as a reference that an engineer can implement from.

The spec section MUST cover these areas in order:

**1. Appliance Overview**
- Role: Flower SuperLink (FL coordinator / aggregation server)
- Marketplace appliance type: QCOW2 VM image
- Architecture: Docker-in-VM (single container per VM)

**2. Image Components**
Specify every component baked into the QCOW2 image:
- Base OS: Ubuntu 24.04 LTS (Noble Numbat) -- validated compatible with Flower Docker images which use the same Ubuntu 24.04 base
- Docker CE 24+ (minimum version constraint, not pinned)
- Pre-pulled Docker image: `flwr/superlink:1.25.0` (default tag `1.25.0-py3.13-ubuntu24.04`)
- OpenNebula one-apps contextualization packages (latest)
- Supporting tools: jq, curl (for OneGate interactions)
- Custom scripts at `/opt/flower/scripts/` (configure.sh, bootstrap.sh, health-check.sh, common.sh)

**3. File Layout Inside the VM**
Specify the directory structure from the research:
```
/etc/one-appliance/service
/opt/flower/scripts/{configure.sh, bootstrap.sh, health-check.sh, common.sh}
/opt/flower/config/superlink.env
/opt/flower/certs/ (placeholder for Phase 2)
/opt/flower/state/ (persistent state directory)
/var/log/one-appliance/{flower-configure.log, flower-bootstrap.log}
```

**4. Pre-baked Image Strategy**
- QCOW2 ships with Docker CE installed and `flwr/superlink:1.25.0` pre-pulled
- Rationale: edge AI environments have unreliable networks; pre-baked eliminates boot-time network dependency
- `FLOWER_VERSION` context variable can override; triggers pull of different version at boot
- Fallback: if pull of override version fails, fall back to pre-baked version with warning log
- Estimated image size: ~2-3 GB (Ubuntu 24.04 + Docker CE + Flower image)

**5. Recommended VM Resources**
- Minimum: 2 vCPU, 4096 MB RAM, 20 GB disk
- Recommended: 4 vCPU, 8192 MB RAM, 40 GB disk
- Note: sizing depends on model size and number of connected SuperNodes

**6. Linear Boot Sequence**
Specify the exact boot sequence as numbered steps (from research):
1. OS Boot + one-apps contextualization packages run (networking, SSH key injection)
2. [configure.sh] Source `/run/one-context/one_env` to read all CONTEXT variables
3. [configure.sh] Validate required variables, set defaults for optional ones (fail-fast on errors)
4. [configure.sh] Generate Docker run configuration: write `superlink.env` file, prepare volume mounts
5. [configure.sh] Create mount-target directories and set ownership to UID 49999 (`chown -R 49999:49999 /opt/flower/state /opt/flower/certs`)
6. [configure.sh] Write systemd unit file for the Flower SuperLink container
7. [bootstrap.sh] Wait for Docker daemon readiness (`until docker info >/dev/null 2>&1; do sleep 1; done`)
8. [bootstrap.sh] Handle version override: if FLOWER_VERSION differs from pre-baked, attempt pull with fallback
9. [bootstrap.sh] Start Flower SuperLink container via systemd unit
10. [bootstrap.sh] Wait for SuperLink to listen on port 9092 (health check loop using `nc -z localhost 9092`)
11. [bootstrap.sh] Publish endpoint to OneGate: FL_READY=YES, FL_ENDPOINT=<ip>:9092, FL_VERSION, FL_ROLE=superlink
12. [REPORT_READY] Contextualization reports VM as READY to OpenNebula

For each step, explain WHAT happens, WHY it matters, and WHAT failure looks like.

**7. Docker Container Configuration**
Specify the Docker run parameters for subprocess mode, no TLS (Phase 1 default):
- Image: `flwr/superlink:${FLOWER_VERSION:-1.25.0}`
- Ports: 9091 (ServerAppIo API), 9092 (Fleet API -- SuperNodes connect here), 9093 (Control API)
- Volumes: `/opt/flower/state:/app/state` (persistent state)
- Restart policy: `unless-stopped`
- Environment: `FLWR_LOG_LEVEL` from context variable
- CLI flags: `--insecure`, `--isolation subprocess`, `--database state/state.db`, `--fleet-api-address`, `--control-api-address`
- Note: `--insecure` is Phase 1 only; Phase 2 replaces with TLS certificates

Include the exact Docker run command as a reference.

**8. Systemd Integration**
Specify the systemd unit design:
- Unit name: `flower-superlink.service`
- After/Requires: `docker.service`
- ExecStartPre: pull override version if needed
- ExecStart: `docker start -a flower-superlink` (container created during configure phase)
- ExecStop: `docker stop flower-superlink`
- Restart: `on-failure` with `RestartSec=5s`
- This ensures Docker manages the container lifecycle and systemd provides process supervision

**9. Health Check and Readiness**
- Primary health check: TCP port check on 9092 (`nc -z localhost 9092`)
- READY_SCRIPT: `/opt/flower/scripts/health-check.sh` -- returns 0 when SuperLink is accepting connections
- REPORT_READY=YES gating: VM reports READY only after Flower container passes health check
- Future consideration: Flower's `--health-server-address` gRPC health endpoint (sparse docs, defer to later phases)

**10. OneGate Publication Contract**
Specify exactly what the SuperLink publishes to OneGate after becoming healthy:
- `FL_READY=YES` -- signals readiness to SuperNodes
- `FL_ENDPOINT=<vm_ip>:9092` -- the Fleet API address SuperNodes should connect to
- `FL_VERSION=<flower_version>` -- for version matching validation
- `FL_ROLE=superlink` -- role identifier
Include the curl command for the OneGate PUT.

**11. Failure Modes and Error Handling**
Document what happens when things go wrong:
- Docker daemon fails to start: log error, do NOT report ready, VM stays in boot state
- Flower container exits immediately: check `docker logs flower-superlink` for UID permission errors on mounted dirs
- Health check times out (60s default): log error, do NOT report ready
- OneGate publication fails: log warning but still report ready (OneGate failure should not block standalone usage)
- Version override pull fails: fall back to pre-baked with warning log

**12. SuperLink Contextualization Parameters**
Include the SuperLink-specific parameter table from research (FLOWER_VERSION, FL_NUM_ROUNDS, FL_STRATEGY, FL_MIN_FIT_CLIENTS, FL_MIN_EVALUATE_CLIENTS, FL_MIN_AVAILABLE_CLIENTS, FL_FLEET_API_ADDRESS, FL_CONTROL_API_ADDRESS, FL_ISOLATION, FL_DATABASE, FL_LOG_LEVEL) with brief descriptions. The comprehensive reference table will be in the contextualization reference spec (Plan 03), but each appliance spec should list its own parameters for standalone readability.

**13. Immutability Model**
- Appliance is immutable after initial boot
- No reconfiguration mechanism: if parameters need to change, redeploy
- Rationale: OpenNebula contextualization runs once at boot; Flower containers are long-running daemons; redeployment via OneFlow is the standard operational pattern

**Writing style guidelines:**
- Write as a technical specification, not a tutorial
- Use imperative mood for requirements ("The SuperLink appliance SHALL...")
- Include code blocks for Docker commands, file paths, and configuration examples
- Each section should be self-contained enough to implement without reading other sections
- Use tables for structured data (parameters, ports, volumes)
- Note open questions from research with their recommendations (especially REPORT_READY + OneFlow interaction)
- Mark Phase 2+ touchpoints clearly (e.g., TLS certificates, GPU support)
  </action>
  <verify>
Verify the file exists and covers all required areas:
- `ls -la /home/pablo/flower-opennebula/spec/01-superlink-appliance.md` (file exists)
- Check the file contains sections for: Image Components, Boot Sequence, Docker Configuration, OneGate Publication, Health Check, Failure Modes, Parameters
- Check the file references all SuperLink contextualization variables (FLOWER_VERSION, FL_NUM_ROUNDS, FL_STRATEGY, etc.)
- Check the file includes the Docker run command
- Check the file documents the OneGate PUT contract
- Verify no TLS implementation details leak in (Phase 2 scope) -- only placeholders/mentions
  </verify>
  <done>
`spec/01-superlink-appliance.md` exists and an engineer can:
1. Identify every component in the SuperLink QCOW2 image
2. Trace the complete boot sequence from OS boot to REPORT_READY
3. Understand the Docker container configuration (ports, volumes, flags)
4. Know exactly what gets published to OneGate and when
5. Handle failure scenarios according to documented behavior
  </done>
</task>

</tasks>

<verification>
- The spec section is a standalone reference for the SuperLink appliance
- All APPL-01 requirements are addressed (QCOW2 packaging, Docker-in-VM, boot-time initialization, contextualization parameters)
- The OneGate publication contract is concrete enough for the SuperNode spec (Plan 02) to reference
- Boot sequence steps are numbered and traceable
- No implementation leaked in -- this is spec, not code
</verification>

<success_criteria>
- `spec/01-superlink-appliance.md` exists with all 13 sections
- An engineer reading only this file can build the SuperLink appliance
- The file covers APPL-01 requirement completely
- Zero-config defaults are documented (FedAvg, 3 rounds, insecure mode, subprocess isolation)
- Phase 2+ touchpoints (TLS, GPU) are marked as placeholders, not implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-base-appliance-architecture/01-01-SUMMARY.md`
</output>
